# -*- coding: utf-8 -*-
"""Netflix_Analysis_by_Pritam.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qhKxB123Spg5WB7drm19BenHi7cnA4uh

## **Netflix Analysis**
This netflix dataset consists of data related to cast, directors, ratings, release year, duration, etc on which an Exploratory Data Analysis will be performed.
"""

# Importing the required libraries
# Pandas and Numpy libraries will be used for data manipulations and Matplotlib and Seaborn will be used for data visualizations which will be required for Analysis.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Data Preprocessing
netflix_data = pd.read_csv('/content/netflix.csv')  # Let's have a look at the data and import the dataset
netflix_data.head(10)

netflix_data.shape   # Represents 8807 rows and 12 columns

netflix_data.info()
# As per the below data we can tell that there are missing values in the following columns and also can have a look at every column's datatype:
# 'director','cast','country','date_added','rating','duration' -> These columns and their missing values needs to be handled first!

netflix_data.isna().sum()      # The number of missing values in each column

"""### -> Before filling the missing values with some relevant data let's handle the nested data that is observed in columns 'director', 'cast', 'country' and also for the column 'listed_in' though it doesn't have any missing value in it. Each column will be turned from nested data to unnested data with respect to it's title.

## **Step 1:** Converting Nested data to Unnested data
"""

# Function to split the nested data in a column and then concatenate it with the original df
def split_data(df, column_name):
    # Split the specified column
    df_split = df[column_name].str.split(', ', expand=True)

    # Renaming the columns
    df_split.columns = [f'{column_name}_{i}' for i in range(len(df_split.columns))]

    # Concatenate the split columns with the original DataFrame
    df = pd.concat([df, df_split], axis=1)
    return df

# Function to stack the splitted columns into a single column for a given df
def stack_split_columns(df, column_name):
    # Create a list of column names that were split
    split_columns = [f'{column_name}_{i}' for i in range(len(df.filter(like=f"{column_name}_").columns))]

    # Stack the DataFrame based on the "title" column
    df_stacked = df.set_index('title')[split_columns].stack().reset_index(level=1, drop=True).reset_index()
    df_stacked.columns = ['title', column_name]

    return df_stacked

"""## **Handling the nested data for "director" column**"""

directors_split = split_data(netflix_data, 'director')
directors_split.head()

directors_stack = stack_split_columns(directors_split, 'director')
directors_stack

directors_stack['title'].value_counts()

netflix_data['title'].count() - netflix_data['director'].isna().sum()

directors_stack['director'].nunique()

directors_stack.groupby('title')['director'].get_group('HALO Legends')

"""## **Handling nested data for "cast" column**"""

cast_split = split_data(netflix_data, 'cast')
cast_split.head()

cast_stack = stack_split_columns(cast_split, 'cast')
cast_stack

cast_stack['title'].value_counts()

netflix_data['title'].count() - netflix_data['cast'].isna().sum()

cast_stack.groupby('title')['cast'].get_group('Black Mirror') # Has the highest cast

"""## **Handling the nested data for "country" column**"""

country_split = split_data(netflix_data, 'country')
country_split.head()

country_stack = stack_split_columns(country_split, 'country')
country_stack

country_stack['title'].value_counts()

netflix_data['title'].count() - netflix_data['country'].isna().sum()

country_stack.groupby('title')['country'].get_group('Barbecue')

country_stack['country'].nunique()

country_stack['country'].unique()

"""## **Handling nested data for "listed_in" column**"""

listed_in_split = split_data(netflix_data, 'listed_in')
listed_in_split.head()

listed_in_stack = stack_split_columns(listed_in_split, 'listed_in')
listed_in_stack

listed_in_stack['title'].value_counts()

netflix_data['title'].count() - netflix_data['listed_in'].isna().sum()

listed_in_stack.groupby('title')['listed_in'].get_group('Zubaan')

listed_in_stack['listed_in'].unique()

listed_in_stack['listed_in'].nunique()

"""## **Let's merge all the 4 dataframes (directors_stack, cast_stack, country_stack, listed_in_stack)with respect to 'title' to get the final dataframe**"""

merged_df = pd.merge(cast_stack, directors_stack, on='title', how='outer')
merged_df = pd.merge(merged_df, country_stack, on='title', how='outer')
merged_final = pd.merge(merged_df, listed_in_stack, on='title', how='outer')

merged_final.head()

df_final = pd.merge(netflix_data, merged_final, on='title', how='left')

df_final.head()

netflix_data.shape, merged_final.shape, df_final.shape

# After looking at the final dataframe we can remove all the unnecessary columns ending with 'x' and keep the columns ending with 'y'
df_final.drop(['director_x','cast_x','country_x','listed_in_x'], axis=1, inplace=True)

# Rename the required columns to respective relevant names
df_final.rename(columns = {'director_y':'director','cast_y':'cast','country_y':'country','listed_in_y':'listed_in'}, inplace=True)

df_final.head()

df_final.shape, netflix_data.shape  #Check for the total columns from the original dataset with the final dataframe

df_final.info()

df_final.describe()

"""## **Step 2:** Handling Missing values in the dataset"""

df_final.head()

df_final.isna().sum()

"""As we can see we need to handle missing values for the columns 'date_added', 'rating', 'duration', 'cast', 'director' and 'country'. We can fill the missing values with the most frequently occurred value and to make it a more appropriate value we'll fill the values with respect to it's 'type'."""

df_final['type'].unique()

movie_fill_value = df_final.loc[df_final['type'] == 'Movie', 'date_added'].mode()
movie_fill_value

tv_show_fill_value = df_final.loc[df_final['type'] == 'TV Show', 'date_added'].mode()
tv_show_fill_value

df_final.loc[df_final['type'] == 'Movie'].isna().sum()  # Since the type 'Movie' for 'date_added' column have zero missing values we can ignore this

df_final.loc[df_final['type'] == 'TV Show'].isna().sum() # Since there are 158 missing values for the 'date_added; column of type 'TV Show', we can update the missing values

# Based on the above information we'll update the missing values for the 'date_added' column
df_final['date_added'].fillna(tv_show_fill_value[0], inplace=True)

df_final.loc[df_final['date_added'] == 'July 6, 2021'] # The most frequently occured date for 'date_added' column of type 'TV Show'

df_final.isna().sum()  # Confirmation for date_added column, the missing values has been filled

# Let's fill the missing values for the 'rating' column in the same way
rating_movie_type = df_final.loc[df_final['type'] == 'Movie', 'rating'].mode()
rating_movie_type

rating_tv_show_type = df_final.loc[df_final['type'] == 'TV Show', 'rating'].mode()
rating_tv_show_type

# Since the frequently occured value is same for both the types we can use any of the above two variable values
df_final['rating'].fillna(rating_movie_type[0], inplace=True)

df_final.loc[df_final['rating'] == 'TV-MA']

df_final.isna().sum()   # Confirmation for rating column, the missing values has been filled

duration_movie_type = df_final.loc[df_final['type'] == 'Movie', 'duration'].mode()
duration_movie_type

duration_tv_show_type = df_final.loc[df_final['type'] == 'TV Show', 'duration'].mode()
duration_tv_show_type

df_final.loc[df_final['type'] == 'Movie', 'duration'].isna().sum() # Here since all the 3 missing values are for type 'Movie', we call fill it with the relevant value

df_final['duration'].fillna(duration_movie_type[0], inplace=True)

df_final.isna().sum()

# Let's fill the missing values for 'cast' column in the same way
cast_movie_type = df_final.loc[df_final['type'] == 'Movie', 'cast'].mode()
cast_movie_type

cast_tv_show_type = df_final.loc[df_final['type'] == 'TV Show', 'cast'].mode()
cast_tv_show_type

df_final.loc[df_final['type'] == 'Movie', 'cast'].isna().sum()

df_final.loc[df_final['type'] == 'TV Show', 'cast'].isna().sum()

cast_movie_type[0], cast_tv_show_type[0]

movie_rows = df_final['type'] == 'Movie'
tv_show_rows = df_final['type'] == 'TV Show'

df_final.loc[movie_rows, 'cast'] = df_final.loc[movie_rows, 'cast'].fillna(cast_movie_type[0])

df_final['cast'].isna().sum()  # Only missing values for tv_show rows are left to be filled

df_final.loc[tv_show_rows, 'cast'] = df_final.loc[tv_show_rows, 'cast'].fillna(cast_tv_show_type[0])

df_final.isna().sum()   # Confirmation for cast column, the missing values has been filled

director_movie_type = df_final.loc[movie_rows, 'director'].mode()
director_movie_type

director_tv_show_type = df_final.loc[tv_show_rows, 'director'].mode()
director_tv_show_type

df_final.loc[df_final['type'] == 'Movie', 'director'].isna().sum()

df_final.loc[df_final['type'] == 'TV Show', 'director'].isna().sum()

df_final.loc[movie_rows, 'director'] = df_final.loc[movie_rows, 'director'].fillna(director_movie_type[0])

df_final['director'].isna().sum()  # Remaining missing values to be filled for type 'TV Show'

# Confirmation for director column, the missing values has been filled
df_final.loc[tv_show_rows, 'director'] = df_final.loc[tv_show_rows, 'director'].fillna(director_tv_show_type[0])

df_final.isna().sum()

# Let's handle the missing values for the last 'country' column
country_movie_type = df_final.loc[movie_rows, 'country'].mode()
country_movie_type

country_tv_show_type = df_final.loc[tv_show_rows, 'country'].mode()
country_tv_show_type

# Since the most frequently occuring value is the same for both the types, we can fill with any of the above two variable values
df_final['country'].fillna(country_movie_type[0], inplace=True)

df_final.isna().sum()    # Confirmation for country column, the missing values has been filled

"""## **Step 3:** Fixing the datatypes"""

df_final.head()

df_final.info()

# As per the above data, we can update the datatype for 'date_added' column to datetime object/datatype.
df_final['date_added'] = pd.to_datetime(df_final['date_added'])

df_final.info()

df_final['date_added'].iloc[0]

df_final['date_added'][0].day

df_final['date_added'][0].year

df_final['date_added'][0].strftime('%Y')

df_final['date_added'][0].month_name()

df_final.head()

# Also the duration column needs to be fixed as it has data in terms of minutes and seasons. We need to convert this column into a numerical format with respect to the 'type'
# column. If duration is of type 'Movie' then the number represents minutes and if type 'TV Show', the number represents seasons.
df_final['duration'] = df_final['duration'].apply(lambda x: x.split(' ')[0])

df_final.head()

# Now we'll change the datatype for the duration column
df_final.info()

df_final['duration'] = pd.to_numeric(df_final['duration'])

df_final.info()

df_final['duration'].dtype         #Confirmation of the datatype change for the duration column

# Statistical Analysis for the final dataframe
df_final.describe()

"""# **Insights and Recommendations**"""

df_final.head()

df_final['added_month'] = df_final['date_added'].dt.month
df_final['added_year'] = df_final['date_added'].dt.year

"""## 1) Content comparison for Content-type"""

plt.figure(figsize = (8,6))
sns.countplot(data = df_final, x = 'type', hue='type')
plt.title('Count comparison for Content-Type')
plt.show()                                                       # This is a Univariate Analysis as we have only one variable 'type' which is Categorical

movie_data = df_final.loc[df_final['type'] == 'Movie']
movie_data.head()

tv_show_data = df_final.loc[df_final['type'] == 'TV Show']
tv_show_data.head()

plt.figure(figsize = (15,8))


sns.lineplot(data = movie_data['added_year'].value_counts().to_frame(), x = movie_data['added_year'].value_counts().index, y = movie_data['added_year'].value_counts(),
             color = 'Blue', marker='o')
sns.lineplot(data = tv_show_data['added_year'].value_counts().to_frame(), x = tv_show_data['added_year'].value_counts().index, y = tv_show_data['added_year'].value_counts(),
             color = 'Red', marker = 'o')
plt.title("Movies vs. TV Shows on Netflix\nCount of Titles added per Year")
plt.xlabel('date_added')
plt.ylabel('Number of Movies/TV Shows')
plt.legend(['Movies', 'TV Shows'])

plt.show()                                        # Bivariate Analysis as two variables are used Numerical (Year) and Numerical (Count)

"""**Insights:** As per the above graph we can observe that most of the movies and tv shows added by netflix were in the years from 2018 to 2020. Also Netflix has been focusing on adding more of Movie content compared to TV Shows over the years."""

movie_count = df_final.loc[df_final['type'] == 'Movie', 'type'].count()
movie_count

tv_show_count = df_final.loc[df_final['type'] == 'TV Show', 'type'].count()
tv_show_count

movie_count_perc = (movie_count/(movie_count + tv_show_count))*100
np.round(movie_count_perc, 2)

tv_show_count_perc = (tv_show_count/(movie_count + tv_show_count))*100
np.round(tv_show_count_perc, 2)

"""### **Insight** : The content produced for the number of Movies is much greater than that of TV Shows with a percentage of 72.2% and 27.8% respectively

## 2) What type of content is available in different countries?
"""

content_distribution = df_final.groupby(['country', 'type']).size().unstack(fill_value=0)
top_5_countries = content_distribution.sort_values(['Movie', 'TV Show'], ascending=[False, False])[:5]
top_5_countries

plt.figure(figsize=(10, 6))

# Let's plot a stacked bar plot for each country
sns.barplot(data = top_5_countries.reset_index(), x='country', y='Movie', color='red', label='Movie')
sns.barplot(data = top_5_countries.reset_index(), x='country', y='TV Show', color='black', label='TV Show')

plt.title('Content Distribution by Country')
plt.xlabel('Country')
plt.ylabel('Count')
plt.legend(title='Type')
plt.xticks(rotation=90)
plt.show()                                                      # This is a Bivariate Analysis as it has two variables, Categorical (country) and Numerical (Movie/TV Show)

bottom_5_countries = content_distribution.sort_values(['Movie', 'TV Show'], ascending=[True, True])[:5]
bottom_5_countries

plt.figure(figsize=(10, 6))

# Let's plot a stacked bar plot for each country
sns.barplot(data = bottom_5_countries.reset_index(), x='country', y='Movie', color='red', label='Movie')
sns.barplot(data = bottom_5_countries.reset_index(), x='country', y='TV Show', color='black', label='TV Show')

plt.title('Content Distribution by Country')
plt.xlabel('Country')
plt.ylabel('Count')
plt.legend(title='Type')
plt.xticks(rotation=90)
plt.show()                                                      # This is a Bivariate Analysis as it has two variables, Categorical (country) and Numerical (TV Show)

"""**Insights:** From the above graphs we can observe that the top 5 countries where the highest number of Movies and TV Shows have run are in United States, India, United Kingdom, France and Canada.

Similarly the bottom 5 countries where the lowest number of Movies and TV Shows have run are in Belarus, Cyprus, Cuba, Puerto Rico and Azerbaijan.  
"""

df_final.head()

# Considering data for the top 5 countries
top5_country_data = df_final.loc[df_final['country'].isin(top_5_countries.index)]
top5_country_data.head()

top5_country_data['country'].unique()

top5_content_df = top5_country_data.groupby(['country','type'])['listed_in'].value_counts().to_frame()

top5_content_df.rename(columns = {'listed_in':'value'}, inplace=True)
top5_content_df

top5_content_df = top5_content_df.reset_index()
top5_content_df.head()

#Top 5 Country-wise Content Analysis for type "Movie"

plt.figure(figsize = (12,25)).suptitle('Top 5 Country-wise Content Analysis for type "Movie"', y = 1)

plt.subplot(5,1,1)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'United States') & (top5_content_df['type'] == 'Movie')], x = 'listed_in', y = 'value', color = 'Red')
plt.title('Content distribution by "listed in" for United States')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,2)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'India') & (top5_content_df['type'] == 'Movie')], x = 'listed_in', y = 'value', color = 'Blue')
plt.title('Content distribution by "listed in" for India')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,3)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'United Kingdom') & (top5_content_df['type'] == 'Movie')], x = 'listed_in', y = 'value', color = 'Green')
plt.title('Content distribution by "listed in" for United Kingdom')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,4)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'France') & (top5_content_df['type'] == 'Movie')], x = 'listed_in', y = 'value', color = 'Orange')
plt.title('Content distribution by "listed in" for France')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,5)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'Canada') & (top5_content_df['type'] == 'Movie')], x = 'listed_in', y = 'value', color = 'Yellow')
plt.title('Content distribution by "listed in" for Canada')
plt.xticks(rotation=90, fontsize = 10)

plt.tight_layout()
plt.show()
                                                                      # This is a Bivariate analysis as it involves 2 variables, Categorical (listed_in) and Numerical (Value)

"""**Insights:** The above graphs display the highest number of movies watched for the top 5 countries with respect to the genres.


1) **United States:** The highest number of movies watched here belong to the genre 'comedies' and 'dramas'.   
Recommendation: It is important to focus on producing content that belong to the genre 'comedies' and 'dramas' in the United States to achieve growth.
Also content related to genre 'anime features' is something that is less viewed in the country and is something that can be less focused upon.


2) **India:** The highest number of movies watched here belong to the genre 'International Movies' followed by 'Dramas'.
Recommendation: Here we can focus on producing movie content which mainly belong to the genre 'International Movies' and then 'Dramas' and can less focus on genre 'stand-up comedy' as it is something that seems less viewed on netflix by most of the Indians.


3) **United Kingdom:** The highest number of movies watched here belong to the genre 'Dramas' followed by 'International Movies'.
Recommendation: Here we can focus on producing movie content which mainly belong to the genre 'Dramas' and then 'International Movies' and can less focus on genre 'movies' as it is something that seems less viewed on netflix by most of its residents.


4) **France:** The highest number of movies watched here belong to the genre 'International Movies' and 'Dramas' as both have almost an equal number.
Recommendation: Here we can focus on producing movie content which belong to the genre 'International Movies' and 'Dramas' and can less focus on genre 'stand-up comedy','LGBTQ movies' and 'movies' as it is something that seems less viewed on netflix by most of its residents.


5) **Canada:** The highest number of movies watched here belong to the genre 'Comedies' followed by 'Children and Family movies' and then 'Dramas'.
Recommendation: Here we can focus on producing movie content which belong to the genre 'Comedies','Children and Family movies' and 'Dramas' and can less focus on genre 'stand-up comedy' as it is something that seems less viewed on netflix by most of its residents.
"""

#Top 5 Country-wise Content Analysis for type "TV Show"

plt.figure(figsize = (12,25)).suptitle('Top 5 Country-wise Content Analysis for type "TV Show"', y = 1)

plt.subplot(5,1,1)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'United States') & (top5_content_df['type'] == 'TV Show')], x = 'listed_in', y = 'value', color = 'Red')
plt.title('Content distribution by "listed in" for United States')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,2)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'India') & (top5_content_df['type'] == 'TV Show')], x = 'listed_in', y = 'value', color = 'Blue')
plt.title('Content distribution by "listed in" for India')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,3)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'United Kingdom') & (top5_content_df['type'] == 'TV Show')], x = 'listed_in', y = 'value', color = 'Green')
plt.title('Content distribution by "listed in" for United Kingdom')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,4)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'France') & (top5_content_df['type'] == 'TV Show')], x = 'listed_in', y = 'value', color = 'Orange')
plt.title('Content distribution by "listed in" for France')
plt.xticks(rotation=90, fontsize = 10)

plt.subplot(5,1,5)
sns.barplot(data = top5_content_df.loc[ (top5_content_df['country'] == 'Canada') & (top5_content_df['type'] == 'TV Show')], x = 'listed_in', y = 'value', color = 'Yellow')
plt.title('Content distribution by "listed in" for Canada')
plt.xticks(rotation=90, fontsize = 10)

plt.tight_layout()
plt.show()                                                        # This is a Bivariate analysis as it involves 2 variables, Categorical (listed_in) and Numerical (Value)

"""**Insights:** The above graphs display the highest number of TV shows watched for the top 5 countries with respect to the genres.

1) **United States:** The highest number of TV Shows watched here belong to the genre 'TV Dramas' followed by 'TV Comedies' and then 'International TV Shows'.                                                      
Recommendation: It is important to focus on producing content that mainly belong to the genre 'TV Dramas' followed by 'TV Comedies' and then 'International TV Shows' in the United States to achieve growth. Also content related to genre 'TV Shows', 'Science and Nature TV' is something that is less viewed in the country and is something that can be less focused upon.


2) **India:** The highest number of TV Shows watched here mainly belong to the genre 'International TV Shows' followed by 'TV Dramas' which seems almost half of the total watchers.    
 Recommendation: Here we can focus on producing content which mainly belong to the genre 'International TV Shows' and then 'TV Dramas' and can less focus on genre 'TV Thrillers' as it is something that seems less viewed on netflix by most of the Indians.


3) **United Kingdom:** The highest number of TV Shows watched here belong to the genre 'British TV Shows' followed by 'International TV Shows'.                                                                                                             
 Recommendation: Here we can focus on producing content which mainly belong to the genre 'Dramas' and then 'International Movies' and can less focus on genre 'TV Horror', 'TV Mysteries', 'Spanish Language TV Shows' and 'Stand-up Comedy and Talk Shows' as it is something that seems less viewed on netflix by most of its residents.


4) **France:** The highest number of TV Shows watched here belong to the genre 'International TV Shows' and 'TV Dramas' as both have almost an equal number.                   
Recommendation: Here we can focus on producing content which belong to the genre 'International TV Shows' and 'TV Dramas' and can less focus on genre 'Stand-up Comedy and Talk Shows' and 'Science and Nature TV' as it is something that seems less viewed on netflix by most of its residents.


5) **Canada:** The highest number of TV Shows watched here belong to the genre 'Kids TV' followed by 'TV Dramas'.                           
Recommendation: Here we can focus on producing content which belong to the genre 'Kids TV' followed by 'TV Dramas' and can less focus on genre 'Korean TV Shows' and 'Science and Nature TV' as it is something that seems less viewed on netflix by most of its residents.

#### We can conclude that it is important to produce content that align with popular genres in each country and also consider acquiring content from specific countries on high demand.

## 3) Changes in Number of Movies over the years
"""

# We can plot a lineplot to see the trend for the change in number of movies over the years
df_final.head()

df_final['release_year'].unique()

movie_data = df_final.loc[df_final['type'] == 'Movie']
movie_data.head()

movie_data['release_year'].value_counts()

x_var = movie_data['release_year'].value_counts().index
y_var = movie_data['release_year'].value_counts()

movie_data['release_year'].max(), movie_data['release_year'].min()

movie_data.loc[movie_data['release_year'] == 2021, 'release_year'].count(), movie_data.loc[movie_data['release_year'] == 1942, 'release_year'].count()

plt.figure(figsize = (12,6))

sns.lineplot(data = movie_data['release_year'].value_counts().to_frame(), x = x_var, y = y_var, marker='o', color='Red')
plt.title("Number of Movies released over the years")
plt.text(2018, movie_data['release_year'].value_counts().max(), "Highest Number of Movies released (Year: 2018, Count: 17033)")
plt.text(2021, movie_data.loc[movie_data['release_year'] == 2021, 'release_year'].count(), "Max Year (Year: 2021, Count: 5427)")
plt.text(2018, movie_data.loc[movie_data['release_year'] == 1942, 'release_year'].count(), "Min Year (Year: 1942, Count: 6)")
plt.xlabel('Release Year')
plt.ylabel('Number of Movies')
plt.show()                                       # This is a Univariate Analysis as it involves only 1 variable Numerical (release year)

"""**Insights**: The highest number of movies were released in the year 2018 with a number of 17033 as marked on the plot. The number of movies over the years ranges from the year 1942 till the year 2021.

Recommendation: Explore the factors that lead to the peak in the number of movies released in the year 2018. Some of the factors can be popular genres and audience preferences during that time or if the peak was due to a specific content that the users preferences were aligned with then it is required to continue producing that specific content to gain growth in the business.
"""



"""## 4) Rating distribution of Movies vs TV Shows"""

df_final['rating'].unique()

df_final['rating'].nunique()

plt.figure(figsize=(12,8))

sns.countplot(data = df_final, x = 'rating', hue='rating')
plt.title('Netflix Rating Distribution')
plt.show()                            # Univariate Analysis as we are using only one variable, Categorical (Rating)

plt.figure(figsize = (12,6))

sns.countplot(data = df_final, x = 'rating', hue='type')
plt.title('Netflix Rating Distribution seperated by type of release')
plt.show()                                              # This is a bivariate analysis as we are using two variables, Categorical ('Rating') and Categorical ('Type').

"""**Insights:** It is evident from the above graph that, the number of Movies released is more compared to the number of TV Shows almost for all the Ratings except for the Rating 'TV-Y7'. The highest rating preferred for both Movies and TV Shows is the rating 'TV MA' on Netflix.

Recommendation: Since Movies and TV Shows of Rating 'TV MA' are much preferred, it can be taken into consideration to produce more of such content that aligns with the audience preferences.
"""



"""## 5) Distribution of Movie Duration"""

df_final['duration'].nunique()

df_final.loc[df_final['type'] == 'Movie', 'duration'].value_counts()

df_final.loc[df_final['type'] == 'TV Show', 'duration'].value_counts()

plt.figure(figsize = (12,6))

sns.histplot(df_final.loc[df_final['type'] == 'Movie', 'duration'], bins = 10, color = 'orange')
plt.title('Duration Distribution for Movies')
plt.xlabel("Duration")
plt.ylabel("Count")
plt.show()                                                      # Univariate analysis since only one continiuos variable is used, Numerical (duration)

"""**Insights:** From the above graph we can observe that the value with the highest bin ranges from just below 100 mins to 125 mins of time duration.

Recommendation: Consider producing movies with durations that align with the preferences of the audience. For example, there is a peak around a specific duration here (just below 100 mins to 125 mins) ,so creating content within that range may attract more viewers.
"""



"""## 6) Best time to launch a TV Show"""

df_final.head()

tv_show_data = df_final.loc[df_final['type'] == 'TV Show']
tv_show_data.head()

tv_show_data['month_name'] = tv_show_data['added_month'].replace({1:'Jan', 2:'Feb', 3:'Mar', 4:'Apr', 5:'May', 6:'June', 7:'July', 8:'Aug', 9:'Sep', 10:'Oct', 11:'Nov', 12:'Dec'})
tv_show_data.head()

month_data = tv_show_data.groupby('added_year')['month_name'].value_counts().to_frame()
month_data.head()

month_data.rename(columns = {'month_name':'month_count'}, inplace=True)

month_data = month_data.reset_index()

month_data.head()

month_df = pd.pivot(data = month_data, index = 'month_name', columns = 'added_year', values = 'month_count').fillna(0)
month_df.head()

month_df.corr()

plt.figure(figsize = (12,6))

sns.heatmap(month_df, annot=True, fmt=".0f", cmap='Blues')
plt.show()                               # This is a multivariate analysis as month_df contains 3 variables, Numerical (Year), Categorical (Month_Name), Numerical (Month_Count)

"""**Insights:** As per the above heatmap, the initial years doesn't seem to have a large number of TV Shows launched. As years progressed the number of TV Shows launched significantly increased. Based on the above heatmap, the highest number of TV Shows launched was in the month of July and then followed by June.

Recommendation: Analyze the types of TV shows that perform well in July. Are there specific genres, themes, or formats that resonate with viewers during this time? We can use this information to for content planning and production decisions.

## 7) Analysis of Actors/Directors in Different Types of Shows/*Movies*
"""

movie_data = df_final.loc[df_final['type'] == 'Movie']
tv_show_data = df_final.loc[df_final['type'] == 'TV Show']

movie_data.head()

movie_data.groupby(['cast','director'])['title'].nunique().sort_values(ascending=False)

"""**Insights:** From the above data we can say that the actor 'Liam Neeson' and the director 'Martin Scorsese' have been the top actor and director with the most number of movies worked together."""

tv_show_data.groupby(['cast','director'])['title'].nunique().sort_values(ascending=False)

"""**Insights:** From the above data we can say that the actor 'David Attenborough' and the director 'Noam Murro' have been the top actor and director combination when it comes to TV Shows."""

top10_movie_actor = movie_data.groupby(['cast'])['title'].nunique().sort_values(ascending=False).to_frame()[:10]
top10_tv_show_actor = tv_show_data.groupby('cast')['title'].nunique().sort_values(ascending=False).to_frame()[:10]

top10_movie_director = movie_data.groupby('director')['title'].nunique().sort_values(ascending=False).to_frame()[:10]
top10_tv_show_director = tv_show_data.groupby('director')['title'].nunique().sort_values(ascending=False).to_frame()[:10]

plt.figure(figsize = (16, 12)).suptitle('Top 10 Actors & Directors across Movies & TV Shows')

plt.subplot(2,2,1)
sns.barplot(data = top10_movie_actor, x = top10_movie_actor.index, y = 'title')
plt.title('Top 10 actors with the highest number of Movies')
plt.xlabel('Actor')
plt.ylabel('Movie Counts')
plt.xticks(rotation = 45)

plt.subplot(2,2,2)
sns.barplot(data = top10_tv_show_actor, x = top10_tv_show_actor.index, y = 'title')
plt.title('Top 10 actors with the highest number of TV Shows')
plt.xlabel('Actor')
plt.ylabel('TV Show Counts')
plt.xticks(rotation = 45)

plt.subplot(2,2,3)
sns.barplot(data = top10_movie_director, x = top10_movie_director.index, y = 'title')
plt.title('Top 10 directors with the highest number of TV Movies')
plt.xlabel('Director')
plt.ylabel('Movie Counts')
plt.xticks(rotation = 45)

plt.subplot(2,2,4)
sns.barplot(data = top10_tv_show_director, x = top10_tv_show_director.index, y = 'title')
plt.title('Top 10 directors with the highest number of TV Shows')
plt.xlabel('Director')
plt.ylabel('TV Show Counts')
plt.xticks(rotation = 45)

plt.tight_layout()
plt.show()                              # Each graph refers to Bivariate analysis as two variables are used Categorical (Actors/Directors) and NUmerical (Movie/TV Show Counts)

"""**Insights:** From the above graphs for actors across Movies and TV Shows suggest that 'Liam Neeson' and 'David Attenborough' have been the top actors for Movies and TV Shows respectively.
Similarly, from the above graphs for directors across Movies and TV Shows suggest that 'Martin Scorsese' and 'Noam Murro' have been the top directors for Movies and TV Shows respectively.

Recommendation: By Identifying these high-impact actors and directors who consistently contribute to popular and well-received content, we can consider collaborating with them for future projects to use their popularity and attract more viewers.

"""



"""## 8) Is there a correlation between the release year and the ratings count of movies?"""

movie_data = df_final.loc[df_final['type'] == 'Movie']
movie_data.head()

movie_data['rating'].nunique()

movie_data['rating'].unique()

movie_data_corr = movie_data.groupby(['release_year','rating'])['title'].count().to_frame().reset_index()
movie_data_corr.rename({'title':'movie_counts'}, axis=1, inplace=True)
movie_data_corr

plt.figure(figsize = (10,8))

sns.scatterplot(data = movie_data_corr, x = 'release_year', y = 'movie_counts', hue='rating', size = 'movie_counts', sizes=(50,500))
plt.title('Correlation of Movie Counts for various Ratings VS Release Year')
plt.xlabel('Release_Year')
plt.ylabel('Movie_Counts')
plt.show()                                        # This is a Multivariate Analysis as 3 variables are used Categorical (Rating), Numerical (Release Year) and Numerical (Movie Counts)

"""**Insights:** It can be observed that the number of movies have grown over the years and in the recent years it can be seen that movies of rating 'TV-MA' seems to have the highest number of movies to be run on netflix in the recent past. These movie ratings refer to Content for the Mature audience and seems to be in demand.

Recommendation: Consider investing further in producing and acquiring content for a mature audience. This could involve exploring a variety of genres within the 'TV-MA' rating to cater to diverse tastes.

## 9) What is the distribution of Movie Duration across top 5 Highest Movie running countries?
"""

movie_data = df_final.loc[df_final['type'] == 'Movie']
movie_data.head()

top5_countries = movie_data['country'].value_counts().index[:5]
top5_data = movie_data.loc[movie_data['country'].isin(top5_countries)]
top5_data.head()

plt.figure(figsize = (18, 12))

sns.boxplot(data = top5_data, x = 'country', y = 'duration', hue = 'country')
plt.title('Rating Distribution across Top 5 Movie running countries')
plt.xlabel('Country')
plt.ylabel('Duration in mins')
plt.xticks()
plt.show()

"""**Insights:** From the above Boxplot we can observe that for **United States** the movie duration for the box varies around 80 mins to 120 mins approx and the central tendency for the movie duration seems to be 100 mins.

For **United Kingdom** the movie duration for the box varies around 90 mins to 130 mins approx and the central tendency for the movie duration seems to be around 110 mins.

For **India** the movie duration for the box varies around 120 mins to 140 mins approx and the central tendency for the movie duration seems to be around 130 mins.

For **France** the movie duration for the box varies around 90 mins to 110 mins approx and the central tendency for the movie duration seems to be around 100 mins.

For **Canada** the movie duration for the box varies around 80 mins to 120 mins approx and the central tendency for the movie duration seems to be around 90 mins.

All the countries have some outliers showing some rare movie durations which are not within the movie duration range between the whiskers.

Recommendation: Based on the duration variability it is required to understand the preferred duration ranges for movies that the audience prefer to watch, So producing content that aligns with the preferred audience durations would be the key here considering the central tendency for every country which shows the typical movie duration range. Since there are decent number of outliers we can explore whether outliers reflect unique and successful content or opportunities for experimentation. Also can check if any particular genre movies fall in a preferred durations.

## 10) Is there a noticeable difference in the distribution of durations and release years between Movies and TV Shows?
"""

df_final.head()

df_final['country'].value_counts()

top3_countries = df_final['country'].value_counts().index[:3]
top3_countries

top3_country_data = df_final.loc[df_final['country'].isin(top3_countries)]
top3_country_data.head()

plt.figure(figsize = (12,12)).suptitle('Pairplot for correlation of numerical with respect to Release_Year, Duration, Added_Month, Added_Year')

sns.pairplot(top3_country_data, hue='type')

plt.show()                                           # Bivariate Analysis as each graph has only two variables being used

"""**Insights:** For release year, the number of Movies and TV Shows added every year and therefore for the months aswell increased in the recent years. Also the duration for some of the movies have increased along with the quantity of Movies in the recent past. The number of TV Shows also increased as the years passed by with very less number of TV Shows and movies present in the initial years.

For duration, TV Shows have been consistent with their duration in terms of seasons, but for Movies the duration seems to have been increased in the recent past especially the recent releases.

For added month, a fair amount of movies are added every month in the recent years consistently, but the number of TV Shows added seems to be consistent but in less number in comparison with movies.

For added year, most of the movies and tv shows have been added in recent years, as the years passed by the number of Movies/ TV Shows added along with the durations also increased.

Recommendation: Identify the popular genres, actors and directors that contribute to the growth of the business and produce more of such content on consistent basis.
"""



"""## Top 10 actors and their popularity among countries"""

df_final.head()

df_final.loc[df_final['cast'] == 'Shah Rukh Khan', 'country'].unique()

df_final.loc[df_final['cast'] == 'Liam Neeson', 'country'].unique()

cast_data = df_final.groupby('cast')['country'].value_counts().to_frame()
cast_data.loc['Shah Rukh Khan']

cast_data.rename(columns = {'country':'counts'}, inplace=True)
cast_data = cast_data.reset_index()
cast_data.sort_values(['counts', 'country'], ascending=[False,False])

country_count = cast_data.groupby('cast')['country'].nunique().to_frame().reset_index()
country_count.rename(columns = {'country':'country_counts'}, inplace=True)
country_count = country_count.sort_values('country_counts', ascending=False)
country_count[:10]

"""**Insights:** Top 10 actors and the number of countries they seem to be popular in as shown in the above dataframe."""

plt.figure(figsize = (8, 8))

plt.pie(country_count[:10]['country_counts'], labels = country_count[:10]['cast'], autopct='%1.1f%%')
plt.title('Distribution of Country Counts for Top Cast Members')
plt.show()

"""**Insights:** Above is a pie chart that shows the percentage of countries out of the total countries for each actor they are popular in. Liam Neeson is popular in a diverse range of countries, with the highest representation in 62 different countries.

Recommendation: Focusing on producing content that includes those popular actors would be the key to attract the viewers and to gain growth in the business. Consider proper planning while content distribution or marketing strategies keeping the popular actors with their respective countries in mind.
"""

#@title Tudum

fig, ax = plt.subplots(figsize = (8,4))

ax.text(1, 0.5, "NETFLIX", color = 'red', fontsize = 80, ha = 'center', va = 'center')
ax.axis('off')

plt.show()

